#ifndef _SQUAD_MARCH_
#define _SQUAD_MARCH_

// Система отдачи приказов, выполнения для нпц и контроля выполнения для игроков
//  Приказы на перемещения по карте

#include "_macros.fos"
#include "serializator.fos"

#define ORDER_TYPE_POS       ( 0 )
#define ORDER_TYPE_MOVE      ( 1 )
#define ORDER_TYPE_DIR       ( 2 )
#define ORDER_TYPE_ARM       ( 3 )
#define MAX_EXECUTE_TRIES    ( 10 )               // Максимальное число попыток выполнить приказ. Приказ не выполняется, если у нпц есть еще хоть какие-то планы
#define RECHECK_TIME         ( REAL_SECOND( 5 ) ) // Время последующей проверки при провале выполнения приказа.
#define _MarchKey            # (crId) ( "MarchQueue_" + crId )
#define _CommanderKey        # (crId) ( "MarchCommander_" + crId )
#define PID_UNARMED          ( 0 )                // 1000)
// #define DL #(s) (Log(s))
#define DL                   # ( s )
#define STR_LOOSE            ( 5917 )             // Вы что-то сделали не так. Задание провалено.

import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";

class MarchOrder                 // Вспомогательный класс. Приказ криттеру на выполнение некоторых действий
{
    uint8  Type;                 // Тип приказа
    uint16 HexX;                 // Точка, в которой должен стоять игрок. Ось икс
    uint16 HexY;                 // Точка, в которой должен стоять игрок. Ось игрек
    uint8  Steps;                // Число шагов, которые нужно сделать
    uint8  Dir;                  // Направление, в котором должен смотреть игрок
    bool   Armed;                // Вооружен
    bool   Run;                  // Бежать во время перемещения
    uint   TimeCheck;            // Относительное время проверки, когда игрок должен выполнить приказ TODO: Удалить это время
    uint   TimeNext;             // Относительное время отдачи следующего приказа

    void Save( string key )
    {
        Serializator save;
        save.Set( this.Type );
        save.Set( this.HexX );
        save.Set( this.HexY );
        save.Set( this.Steps );
        save.Set( this.Dir );
        save.Set( this.Armed );
        save.Set( this.Run );
        save.Set( this.TimeCheck );
        save.Set( this.TimeNext );
        save.Save( key );
    }

    void Load( string key )
    {
        Serializator load;
        if( !load.Load( key ) )
        {
            Log( "Can't load MarchOrder. Key: " + key );
            return;
        }
        load.Get( this.Type );
        load.Get( this.HexX );
        load.Get( this.HexY );
        load.Get( this.Steps );
        load.Get( this.Dir );
        load.Get( this.Armed );
        load.Get( this.Run );
        load.Get( this.TimeCheck );
        load.Get( this.TimeNext );
    }

    void Erase( string key )
    {
        if( IsAnyData( key ) )
            EraseAnyData( key );
    }

    string ToString()
    {
        string s = "MarchOrder";
        s += "\n type     : " + ( this.Type == ORDER_TYPE_POS ? "ORDER_TYPE_POS" :
                                  ( this.Type == ORDER_TYPE_MOVE ? "ORDER_TYPE_MOVE" :
                                    ( this.Type == ORDER_TYPE_DIR ? "ORDER_TYPE_DIR" : "ORDER_TYPE_ARM" ) ) );
        s += "\n HexX     : " + this.HexX;
        s += "\n HexY     : " + this.HexY;
        s += "\n Steps    : " + this.Steps;
        s += "\n Dir      : " + this.Dir;
        s += "\n Armed    : " + ( this.Armed ? "true" : "false" );
        s += "\n Run      : " + ( this.Run ? "true" : "false" );
        s += "\n TimeCheck: " + this.TimeCheck;
        s += "\n TimeNext : " + this.TimeNext;
        return s;
    }
}

// Формулировки приказов
// Приказ ЗАНЯТЬ ПОЗИЦИЮ
MarchOrder@ DefineSetPosition( uint16 hexX, uint16 hexY, uint8 dir, bool run, uint timeCheck, uint timeNext )
{
    MarchOrder@ order = MarchOrder();
    order.Type      = ORDER_TYPE_POS;
    order.HexX      = hexX;
    order.HexY      = hexY;
    order.Dir       = dir;
    order.Run       = run;
    order.TimeCheck = timeCheck;
    order.TimeNext  = timeNext;
    return order;
}

// Приказ ПЕРЕМЕСТИТЬСЯ
MarchOrder@ DefineMove( uint8 steps,  uint8 dir, bool run, uint timeCheck, uint timeNext )
{
    MarchOrder@ order = MarchOrder();
    order.Type      = ORDER_TYPE_MOVE;
    order.Steps     = steps;
    order.Dir       = dir;
    order.Run       = run;
    order.TimeCheck = timeCheck;
    order.TimeNext  = timeNext;
    return order;
}

// Приказ ПОВОРОТ
MarchOrder @ DefineDirection( uint8 dir, uint timeCheck, uint timeNext )
{
    MarchOrder@ order = MarchOrder();
    order.Type      = ORDER_TYPE_DIR;
    order.Dir       = dir;
    order.TimeCheck = timeCheck;
    order.TimeNext  = timeNext;
    return order;
}

// Приказ ВЗЯТЬ/УБРАТЬ ОРУЖИЕ
MarchOrder @ DefineArmWeapon( bool armed, uint timeCheck, uint timeNext )
{
    MarchOrder@ order = MarchOrder();
    order.Type      = ORDER_TYPE_ARM;
    order.Armed     = armed;
    order.TimeCheck = timeCheck;
    order.TimeNext  = timeNext;
    return order;
}

// Класс для реализации строевой подготовки. Несколько последовательных приказов для каждого криттера.
// Определяющий параметр - Id криттера, у одного криттера - только одна очередь приказов
class MarchQueue
{
    MarchQueue( Critter & cr )
    {
        this.OrderCurrent = -1;
        this.CritterId = cr.Id;
        this.Auto = false;
    }

    MarchQueue( uint crId )
    {
        this.OrderCurrent = -1;
        this.CritterId = crId;
        this.Auto = false;
    }

    bool Auto;                      // Признак: все приказы назначаются автоматически, с помощью time_events
    uint CritterId;                 // Исполнитель приказа
    int8 OrderCurrent;              // Текущий номер приказа
    MarchOrder[] Orders;            // Приказы в порядке выполнения

    void AddOrder( MarchOrder@ order )
    {
        if( valid( order ) )
        {
            this.Orders.insertLast( order );
        }
    }

    void Save()
    {
        if( this.CritterId == 0 )
            return;
        string       key = _MarchKey( this.CritterId );
        uint         orders = this.Orders.length();
        DL( "orders saved:" + orders );
        Serializator save;
        save.Set( this.Auto );
        save.Set( this.CritterId );
        save.Set( this.OrderCurrent );
        save.Set( orders );
        for( uint i = 0; i < orders; i++ )
        {
            this.Orders[ i ].Save( key + i );
        }
        save.Save( key );
    }

    void Load()
    {
        string key = _MarchKey( this.CritterId );
        if( !IsAnyData( key ) )
            return;
        Serializator load;
        if( !load.Load( key ) )
        {
            return;
        }
        uint orders = 0;
        load.Get( this.Auto );
        load.Get( this.CritterId );
        load.Get( this.OrderCurrent );
        load.Get( orders );
        this.Orders.resize( 0 );
        for( uint i = 0; i < orders; i++ )
        {
            MarchOrder@ o = MarchOrder();
            o.Load( key + i );
            this.AddOrder( o );
        }
    }

    void Erase()
    {
        string key = _MarchKey( this.CritterId );
        uint   orders = this.Orders.length();
        for( uint i = 0; i < orders; i++ )
        {
            this.Orders[ i ].Erase( key + i );
        }
        if( IsAnyData( key ) )
            EraseAnyData( key );
        Critter@ cr = GetCritter( this.CritterId );
        if( valid( cr ) && cr.IsNpc() )
            cr.ModeBase[ MODE_NO_HOME ] = 0;
    }

    // Подтверждает выполнение текущего приказа неким криттером. В результате подтверждения координаты
    //  предыдущего приказа приравниваются к текущему положению криттера
    void ConfirmOrder()
    {
        if( this.OrderCurrent < 0 )
            return;
        Critter@ cr = GetCritter( this.CritterId );
        if( !valid( cr ) )
            return;
        MarchOrder@ order = this.Orders[ OrderCurrent ];
        if( !valid( order ) )
            return;
        order.HexX = cr.HexX;
        order.HexY = cr.HexY;
        order.Dir  = cr.Dir;
        this.Save();
    }

    // Проверяет что все условия приказа выполнены
    bool CheckOrderCompleted()
    {
        if( this.OrderCurrent < 0 )
            return true;
        Critter@ cr = GetCritter( this.CritterId );
        if( !valid( cr ) )
            return false;
        MarchOrder@ order = this.Orders[ this.OrderCurrent ];
        if( !valid( order ) )
            return false;
        Item@ weapon;
        switch( order.Type )
        {
        case ORDER_TYPE_POS:
            return ( cr.HexX == order.HexX && cr.HexY == cr.HexY );
        case ORDER_TYPE_MOVE:
            if( this.OrderCurrent == 0 )                   // первый шаг, исходная координата неизвестна
            {
                return true;
            }
            else
            {
                MarchOrder@ orderPrev = this.Orders[ OrderCurrent - 1 ];
                if( !valid( orderPrev ) )
                    return true;
                uint16 hx = orderPrev.HexX;
                uint16 hy = orderPrev.HexY;
                Map@   map = cr.GetMap();
                if( !valid( map ) )
                    return true;
                map.MoveHexByDir( hx, hy, order.Dir, order.Steps );
                return ( cr.HexX == hx && cr.HexY == hy );
            }
        case ORDER_TYPE_DIR:
            return ( cr.Dir == order.Dir );
        case ORDER_TYPE_ARM:
            @weapon = _CritGetItemHand( cr );
            if( valid( weapon ) )
            {
                if( order.Armed )
                {
                    return !weapon.Proto.Weapon_IsUnarmed;
                }
                else
                {
                    return weapon.Proto.Weapon_IsUnarmed;
                }
            }
            return !order.Armed;
        default:
            break;
        }
        return false;
    }

    void ExecuteOrder()
    {
        Critter@ cr = GetCritter( this.CritterId );
        if( !valid( cr ) || cr.IsPlayer() )
            return;             // Игроком выполнить приказ с помощью скрипта нельзя, разумеется
        cr.ModeBase[ MODE_NO_HOME ] = 1;
        MarchOrder@ order = this.Orders[ OrderCurrent ];
        if( !valid( order ) )
            return;
        Map@ map = cr.GetMap();
        if( !valid( map ) )
            return;
        DL( order.ToString() );
        Item@      weapon;
        ProtoItem@ proto;
        Item@[] weapons;
        uint16     hx = 0;
        uint16     hy = 0;
        uint       pid1 = 0;
        uint       pid2 = 0;
        switch( order.Type )
        {
        case ORDER_TYPE_POS:
            AddWalkPlane( cr, 0, order.HexX, order.HexY, order.Dir, order.Run, 0 );
            break;
        case ORDER_TYPE_MOVE:
            if( this.OrderCurrent == 0 )                   // первый шаг, исходная координата неизвестна
            {
                break;
            }
            else
            {
                MarchOrder@ orderPrev = this.Orders[ OrderCurrent - 1 ];
                if( !valid( orderPrev ) )
                    return;
                hx = orderPrev.HexX;
                hy = orderPrev.HexY;
                map.MoveHexByDir( hx, hy, order.Dir, order.Steps );
                AddWalkPlane( cr, 0, hx, hy, order.Dir, order.Run, 0 );
                break;
            }
        case ORDER_TYPE_DIR:
            cr.SetDir( order.Dir );
            break;
        case ORDER_TYPE_ARM:
            @weapon = _CritGetItemHand( cr );
            if( order.Armed )
            {
                if( valid( weapon ) && !weapon.Proto.Weapon_IsUnarmed )
                    break;                             // В руках оружие
                pid1 = cr.GetFavoriteItem( SLOT_HAND1 );
                // Проверяем, что у нпц в другом слоте
                pid2 = cr.GetFavoriteItem( SLOT_HAND2 );
                @proto = GetProtoItem( pid2 );
                if( !valid( proto ) || proto.Type != ITEM_TYPE_WEAPON )
                {
                    if( cr.GetItemsByType( ITEM_TYPE_WEAPON, weapons ) > 0 )
                    {

                        for( uint i = 0, l = weapons.length(); i < l; i++ )
                        {
                            if( weapons[ i ].GetType() == ITEM_TYPE_WEAPON && !weapons[ i ].Proto.Weapon_IsUnarmed )
                                pid2 = weapons[ i ].GetProtoId();
                        }
                    }
                }
                cr.SetFavoriteItem( SLOT_HAND1, pid2 );
                cr.SetFavoriteItem( SLOT_HAND2, pid1 );
            }
            else
            {
                if( valid( weapon ) && !weapon.Proto.Weapon_IsUnarmed )
                {
                    pid1 = weapon.GetProtoId();
                    // Проверяем, что у нпц в другом слоте
                    pid2 = cr.GetFavoriteItem( SLOT_HAND2 );
                    @proto = GetProtoItem( pid2 );
                    if( !valid( proto ) || proto.Type == ITEM_TYPE_WEAPON )
                        pid2 = PID_UNARMED;                                 // Убирание оружия - имитируем с помощью выбора любимым оружием рукопашного удара
                    cr.DropPlanes();
                    cr.SetFavoriteItem( SLOT_HAND1, pid2 );
                    cr.SetFavoriteItem( SLOT_HAND2, pid1 );
                }
            }
            break;
        default:
            break;
        }
    }

    void NextOrder()
    {
        if( this.Orders.length() == 0 )
            return;
        uint        newIndex = this.OrderCurrent + 1;
        MarchOrder@ order;
        if( newIndex >= this.Orders.length() )
        {
            @order = this.Orders[ this.OrderCurrent ];
            if( order.TimeNext == 0 )
            {
                this.Erase();                 // Выполнение всех приказов закончено
                return;
            }
            else
            {
                newIndex = 0;                 // Повторяем заново
            }
        }
        this.OrderCurrent = newIndex;
        this.Save();
        if( this.Auto )
        {
            ExecuteOrder();
            @order = this.Orders[ this.OrderCurrent ];
            if( valid( order ) )
            {
                uint[] values = { this.CritterId, 0 };
                CreateTimeEvent( __FullSecond + order.TimeNext,  "e_NextOrder",  values, false );
            }
        }
    }
}

// Атоматическая проверка, что приказ выполнен для НПЦ с очередью приказов с установленным флагом Auto
// Проверяется, что план выполнен, у НПЦ нет других планов, если это верно, отдается следующий приказ
// иначе делается MAX_EXECUTE_TRIES попыток выполнить приказ
// если приказ не выполним, очередь приказов отменяется
uint e_NextOrder( uint[] @ values )
{
    DL( "next order" );
    Critter@ cr = GetCritter( values[ 0 ] );
    if( !valid( cr ) || values[ 1 ] >= MAX_EXECUTE_TRIES || !cr.IsNpc() )
    {
        return 0;
    }
    MarchQueue@ march = MarchQueue( cr );
    values[ 1 ]++;
    if( cr.IsNoPlanes() && valid( march ) && march.CheckOrderCompleted() )
    {
        march.ConfirmOrder();
        march.NextOrder();
        return 0;
    }
    return RECHECK_TIME;
}

class SquadCommander
{
    SquadCommander( Critter & cr )
    {
        this.CommanderId = cr.Id;
    }

    uint CommanderId;
    uint[] Squad;

    void Save()
    {
        string       key = _CommanderKey( this.CommanderId );
        Serializator save;
        save.Set( this.CommanderId );
        save.Set( this.Squad );
        save.Save( key );
    }

    void Load()
    {
        string key = _CommanderKey( this.CommanderId );
        if( !IsAnyData( key ) )
            return;
        Serializator load;
        if( !load.Load( key ) )
        {
            return;
        }
        load.Get( this.CommanderId );
        load.Get( this.Squad );
    }

    void Erase()
    {
        string key = _CommanderKey( this.CommanderId );
        for( uint i = 0, l = this.Squad.length(); i < l; i++ )
        {
            MarchQueue@ q = MarchQueue( this.Squad[ i ] );
            if( valid( q ) )
            {
                q.Load();
                q.Erase();
            }
        }
        if( IsAnyData( key ) )
            EraseAnyData( key );
    }

    bool CheckCommandExecuted()     // Проверка только для игроков
    {
        for( uint i = 0, l = this.Squad.length(); i < l; i++ )
        {
            MarchQueue@ q = MarchQueue( this.Squad[ i ] );
            q.Load();
            Critter@    cr = GetCritter( this.Squad[ i ] );
            if( !valid( cr ) || !valid( q ) )
            {
                return false;
            }
            if( cr.IsPlayer() && !q.CheckOrderCompleted() )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOOSE );
                return false;

            }
        }
        return true;
    }

    void Command( uint strNum )   // strNum - номер строки из диалога
    {
        Critter@ cr = GetCritter( this.CommanderId );
        if( valid( cr ) && strNum >= 0 )
            cr.SayMsg( SAY_SHOUT, TEXTMSG_DLG, DLGSTR( cr.Stat[ ST_DIALOG_ID ], strNum ) );
        for( uint i = 0, l = this.Squad.length(); i < l; i++ )
        {
            MarchQueue@ q = MarchQueue( this.Squad[ i ] );
            q.Load();
            if( valid( q ) )
            {
                q.ConfirmOrder();
                q.Save();
                DL( "ci = " + q.OrderCurrent );
                q.NextOrder();
                q.Save();
                Critter@ c = GetCritter( q.CritterId );
                if( !valid( c ) )
                    return;
                if( c.IsNpc() )
                    q.ExecuteOrder();
            }
        }
    }
}

#endif // _SQUAD_MARCH_
