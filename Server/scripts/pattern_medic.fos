#include "pattern_common.fos"
#include "teams_table.fos"
/*
   Боевой Медик

   Вооружен энергетическим оружием. Предпочтительно - плазменный пистолет.
   При необходимости лечит себя и своих напарников суперстимпаками. Если у напарника перелом - использует скилл доктора. Если закончились стимпаки - использует навык санитара по таймауту.

   Периодически стреляет в игроков из инъектора специальными патронами. Инъектор снимает положительные эффекты наркотиков и отравляет цель.

   Приоритет действий:

   1 медицинская помощь себе
   2 медицинская помощь своим
   3 использование инъектора на персонажах под психо
   4 атака на расстоянии 20 гексов, если меньше - отступление

   - при смерти - из инвентаря удаляются лишние стимпаки (остается 0..2)
   - при респауне - получает исходное число стимпаков, см. таблицу.
   ----------------------------------------------------------------------------------
   Общие особенности медиков
        PERK_BONUS_RATE_OF_FIRE
        TRAIT_FAST_SHOT
        PERK_LIVING_ANATOMY
    PERK_BONUS_RANGED_DAMAGE
   ---------------------------------------------------------------------------------------
    Параметры для ур  1            2            3            4            5
   -   Легкое/Энерго     90..120      100..130     120..150     140..250     200..300
   -   Доктор/Санитар    70..100      100..150     130..180     170..220     200..300
   -   Крит дополнит.    10%          20%          30%          40%          50%
   -   Число стимпаков   20           30           40           50           80
   -   АР                10           12           14           16           20
   -   HP                120          140          160          180          200
   -   Резисты           20..50       30..50       40..50       40..55       40..65
   ---------------------------------------------------------------------------------------
 */
const int[] medicStats_ =
{
//  WeapMin, WeapMax, HealMin, HealMax, Crit,   NumStim,    AP,   HP,    ResMin,  ResMax
    90,      120,     70,      100,     10,     20,         10,   120,   20,      50,
    100,     130,     100,     150,     20,     30,         12,   140,   30,      50,
    120,     150,     130,     180,     30,     40,         14,   160,   40,      50,
    140,     250,     170,     220,     40,     50,         16,   180,   40,      55,
    200,     300,     200,     300,     50,     80,         20,   200,   50,      65
};
#define M_COUNT                            ( 5 )
#define M_POS                              # (pos) ( ( ( pos < M_COUNT ) ? pos : 0 ) * 10 )
#define M_WEAP                             # (pos) ( Random( medicStats_[ M_POS( pos ) ],   medicStats_[ M_POS( pos ) + 1 ] ) )
#define M_HEAL                             # (pos) ( Random( medicStats_[ M_POS( pos ) + 2 ], medicStats_[ M_POS( pos ) + 3 ] ) )
#define M_CRIT                             # (pos) ( medicStats_[ M_POS( pos ) + 4 ] )
#define M_STIM                             # (pos) ( medicStats_[ M_POS( pos ) + 5 ] )
#define M_AP                               # (pos) ( medicStats_[ M_POS( pos ) + 6 ] )
#define M_HP                               # (pos) ( medicStats_[ M_POS( pos ) + 7 ] )
#define M_RES                              # (pos) ( Random( medicStats_[ M_POS( pos ) + 8 ],  medicStats_[ M_POS( pos ) + 9 ] ) )

#define ID_PLANE_HEAL_TEAMMATE             ( 124 )
#define AI_PLANE_HEAL_TEAMMATE_PRIORITY    ( 80 )
#define AI_PLANE_HEAL_SELF_PRIORITY        ( 81 )
#define AI_PLANE_WAIT_FOR_HEAL_PRIORITY    ( 82 )

#define NEED_HEAL                          # (cr) ( ( 100 * cr.Stat[ ST_CURRENT_HP ] < cr.Stat[ ST_MAX_LIFE ] * 50 ) ) // здоровье ниже 50%

class MedicPattern : CommonPattern
{
    void _Dead( Critter& cr, Critter@ killer )
    {
        CommonPattern::_Dead( cr, killer );
        // У медика полно стимпаков, игрокам не нужна подобная халява
        if( cr.CountItem( PID_SUPER_STIMPAK ) > 0 )
        {
            _SubItem( cr.GetItem( PID_SUPER_STIMPAK, -1 ), cr.CountItem( PID_SUPER_STIMPAK ) );
        }
        if( cr.CountItem( PID_STIMPAK ) > 0 )
        {
            _SubItem( cr.GetItem( PID_STIMPAK, -1 ), cr.CountItem( PID_STIMPAK ) );
        }
    }

    void _Message( Critter& medic, Critter& fromCr, int message, int value )
    {
        // DL("message recieved/ value="+value);

        if( TEAM_PARITY( fromCr.Stat[ ST_TEAM_ID ], medic.Stat[ ST_TEAM_ID ] ) == Anyway )
        {
            return;
        }

        if( !valid( medic.GetMap() ) || !valid( fromCr.GetMap() ) )
            return;

        switch( message )
        {
        case MSG_HEALME:
            DL( "healing needed" );
            MoveForHealTeamMate( medic, fromCr );
            break;
        default:
            break;
        }
    }

    int _PlaneEnd( Critter& medic, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
    {
        DL( "medic plane end" );

        if( plane.Identifier == ID_PLANE_HEAL_TEAMMATE && reason == REASON_SUCCESS )
        {
            Critter @ teammate = GetCritter( plane.IdentifierExt );
            if( valid( teammate ) )
            {
                uint dist = GetCrittersDistantion( medic, teammate );
                if( dist < 2 )             // Расстояние до напарника 1 или 0 гексов - можно лечить.
                {
                    HealTeammate( medic, teammate );
                }
                else
                {
                    // Иначе еще одна итерация приближения.
                    AddMiscPlane( teammate, AI_PLANE_WAIT_FOR_HEAL_PRIORITY, __FullSecond + 60, null );
                    MoveForHealTeamMate( medic, teammate );
                }
            }
        }

        return PLANE_RUN_GLOBAL;         // основной обработчик
    }

    bool _Attacked( Critter& cr, Critter& attacker )
    {
        _TryUseStim( cr );
        cr.SendMessage( MSG_HEALME, 0, MESSAGE_TO_ALL_ON_MAP );
        return false;
    }

    void SetEvents( Critter& cr )
    {
        cr.ModeBase[ MODE_NO_HOME ] = 1;
        cr.SetEvent( CRITTER_EVENT_MESSAGE, "_MedicMessage" );
        cr.SetEvent( CRITTER_EVENT_PLANE_END, "_MedicPlaneEnd" );
        cr.SetEvent( CRITTER_EVENT_ATTACKED, "_MedicAttacked" );
        cr.SetEvent( CRITTER_EVENT_PLANE_BEGIN, "_MedicPlaneBegin" );
        cr.SetEvent( CRITTER_EVENT_DEAD, "_MedicDead" );
    }

    // лечение напарников
    bool CheckTeamMateNeedHeal( Critter& medic, Critter& teammate )
    {
        if( teammate.IsDead() )
            return false;

        // DL("Планов с таким ид, и доп ид.: "+ medic.GetPlanes(ID_PLANE_HEAL_TEAMMATE, teammate.Id, null));

        if( medic.GetPlanes( ID_PLANE_HEAL_TEAMMATE, teammate.Id, null ) > 0 )
            return false;

        return NEED_HEAL( teammate );
    }

    void MoveForHealTeamMate( Critter& medic, Critter& teammate )
    {
        // DL("begin move");
        if( teammate.IsDead() )
            return;
        if( !CheckTeamMateNeedHeal( medic, teammate ) )
            return;
        // DL("coming!");
        // В IdentifierEx сохраняется Id напарника, которого нужно вылечить
        AddWalkPlane( medic, AI_PLANE_HEAL_TEAMMATE_PRIORITY, ID_PLANE_HEAL_TEAMMATE, teammate.Id, teammate.HexX, teammate.HexY, GetDir( medic, teammate ), ( medic.IsCurPlane( AI_PLANE_ATTACK ) ? false : true ), 1 );
    }

    void HealTeammate( Critter& medic, Critter& teammate )
    {
        uint stims = medic.CountItem( PID_SUPER_STIMPAK );

        bool needHeal = NEED_HEAL( teammate );
        bool needDoctor = false;

        for( uint i = DAMAGE_BEGIN; i <= DAMAGE_END; i++ )
        {
            if( teammate.Damage[ i ] > 0 )
            {
                needDoctor = true;
                break;
            }
        }

        bool useStim = ( stims > 0 ? true : false );
        bool canDoctor = ( medic.Timeout[ TO_SK_DOCTOR ] > 0 ? false : true );
        bool canHeal = ( useStim ? true : ( medic.Timeout[ TO_SK_FIRST_AID ] > 0 ) );

        if( needDoctor && canDoctor )
        {
            // не получилось. Использование навыков пока не производится
            // medic.EventUseSkill(SK_DOCTOR, teammate, null, null);
            // DL("Принудительно лечим доктором");
            // return;
        }

        if( canHeal && needHeal )
        {
            if( stims > 0 )
            {
                Item @ stim = medic.GetItem( PID_SUPER_STIMPAK, -1 );
                if( valid( stim ) )
                {
                    DL( "Принудительно лечим стимпаками" );
                    // medic.EventUseItem(stim, teammate, null, null);GetDir(Critter & cr0, Critter & cr1)
                    medic.SetDir( GetDir( medic, teammate ) );
                    _CritAnimateUse( medic );
                    UseDrugOn( medic, teammate, stim );
                    _SubItem( stim, 1 );
                    return;
                }
            }
        }
    }
    // end class
}

#ifndef _NoBaseInstance
MedicPattern pattern; // Для наследников нужно определить _NoBaseInstance
#endif

void _MedicDead( Critter& cr, Critter@ killer )
{
    pattern._Dead( cr, killer );
}

int _MedicPlaneBegin( Critter& cr, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    return pattern._PlaneBegin( cr, plane, reason, someCr, someItem );
}

void _MedicMessage( Critter& medic, Critter& fromCr, int message, int value )
{
    pattern._Message( medic, fromCr, message, value );
}

bool _MedicAttacked( Critter& cr, Critter& attacker )
{
    return pattern._Attacked( cr, attacker );
}

int _MedicPlaneEnd( Critter& medic, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    return pattern._PlaneEnd( medic, plane, reason, someCr, someItem );
}

void SetMedicStats( Critter& cr, uint8 lvl )
{
    lvl = CLAMP( lvl, 0, M_COUNT - 1 );
    if( lvl < 1 )
        return;
    cr.StatBase[ ST_MAX_LIFE ] = M_HP( lvl );
    cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
    cr.StatBase[ ST_LEVEL ] = 24;
    cr.StatBase[ ST_ACTION_POINTS ] = M_AP( lvl );
    cr.StatBase[ ST_CRITICAL_CHANCE ] = M_CRIT( lvl );
    for( int i = ST_NORMAL_RESIST; i <= ST_POISON_RESISTANCE; i++ )
    {
        if( i != ST_EMP_RESIST )
        {
            cr.StatBase[ i ] = M_RES( lvl );
        }
    }

    cr.SkillBase[ SK_FIRST_AID ] = M_HEAL( lvl );
    cr.SkillBase[ SK_DOCTOR ] = M_HEAL( lvl );
    cr.SkillBase[ SK_SMALL_GUNS ] = M_WEAP( lvl );
    cr.SkillBase[ SK_ENERGY_WEAPONS ] = M_WEAP( lvl );

    cr.TraitBase[ TRAIT_FAST_SHOT ] = 1;

    cr.PerkBase[ PE_BONUS_RATE_OF_FIRE ] = 1;
    cr.PerkBase[ PE_LIVING_ANATOMY ] = 1;
    cr.PerkBase[ PE_BONUS_RANGED_DAMAGE ] = 1;
}

void _MedicInit( Critter& cr, bool firstTime )
{
    _CritterInit( cr, firstTime );
}

/* ************************************************* DEBUG ************************************************* */
void testMedic( Critter& cr, int lvl, int team, int bag )
{
    int[] params = { ST_BAG_ID, bag, ST_TEAM_ID, team };
    int[] items = { PID_SUPER_STIMPAK, 20, SLOT_INV };
    Critter @ npc = cr.GetMap().AddNpc( 222, cr.HexX - 3, cr.HexY - 3, 0, params, items, "pattern_medic@init" );
    SetMedicStats( npc, lvl );
}
// ~run pattern_medic test 0 0 0
// ~run test SetStat 1 7 1000
// ~run test SetStat 1 72 1000
