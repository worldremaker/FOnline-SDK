// Author: cvet
// For test reasons, can be exluded in any time

#include "_macros.fos"
#include "_colors.fos"

void test( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    if( not valid( map ) )
        return;
    Item@ car = map.AddItem( p0, p1, PID_HUMMER, 1 );
    // if(not valid(car)) return;
    SETFLAG( car.Flags, ITEM_GECK );
    car.Update();
}

void test1( Critter& cr, int p0, int p1, int p2 )
{
    cr.Say( SAY_NORM, "русские буквы АБВгДееейёёёё!" );
}

class Example
{
    int    a;
    int8   b;
    uint16 c;
    uint64[] arr;
    string str;
}

#include "serializator.fos"
void test2( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    e.a = -100;
    e.b = 123;
    e.c = 60000;
    e.str = "Example!";
    e.arr.resize( 5000 );

    for( uint i = 0; i < 10; i++ )
    {
        Serializator save;
        save.Set( e.arr ).Set( e.a ).Set( e.b ).Set( e.c ).Set( e.str ).Save( "Example_" + i );
    }

    cr.Say( SAY_NETMSG, "0<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void test3( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    for( uint i = 0; i < 10; i++ )
    {
        Serializator load;
        if( load.Load( "Example_" + i ) )
            load.Get( e.arr ).Get( e.a ).Get( e.b ).Get( e.c ).Get( e.str );
    }


    cr.Say( SAY_NETMSG, "1<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void zero( Critter& cr, int p0, int p1, int p2 )
{
//	float timeout = 2.0f;
//	float factor = 0.5f;
    float t = 1.0f / 0.9f;
    cr.Say( SAY_NETMSG, "!!!!!!!!!!!!!!" );
}

void test4( Critter& cr, int p0, int p1, int p2 )
{
    uint16 year = 0;
    uint16 month = 0;
    uint16 day_of_week = 0;
    uint16 day = 0;
    uint16 hour = 0;
    uint16 minute = 0;
    uint16 second = 0;
    GetGameTime( __FullSecond, year, month, day, day_of_week, hour, minute, second );
    uint   fm = GetFullSecond( year, month, day, hour, minute, second );

    Log( "Real: " + "FullSecond " + __FullSecond + " Year " + __Year + " Month " + __Month + " Day " + __Day + " Hour " + __Hour + " Minute " + __Minute + " Second " + __Second );
    Log( "Calc: " + "FullSecond " + fm + " Year " + year + " Month " + month + " Day " + day + " Hour " + hour + " Minute " + minute + " Second " + second + " DayOfWeek " + day_of_week );
}

/*
   void init(Critter@ npc, bool firstTime)
   {
        if(firstTime) npc.AddItem(PID_ADVANCED_POWER_ARMOR_MK2,1);
        npc.Wait(20000);
   }

   void idle(Critter@ npc)
   {
   //	TestMove(npc);
        TestObjMove(npc);
   //	TestVars(npc);
   }

   void TestMove(Critter@ npc)
   {
        _CritAnimateUse(npc);

        if(npc.HexX==260 && npc.HexY==209) return;
        npc.AddWalkPlane(260,209,3,false,0);
   }

   void TestObjMove(Critter@ npc)
   {
        npc.Say(SAY_NORM_ON_HEAD,"Эээх мой броник");

        Item@ armor=_CritGetItemArmor(npc);
        if(@armor==null)
        {
                @armor=_CritGetItem(npc,PID_ADVANCED_POWER_ARMOR_MK2);
                if(@armor==null)
                {
                        npc.Say(SAY_NORM_ON_HEAD,"Украли броник");
                        return;
                }

                _CritMoveItem(npc,armor,SLOT_ARMOR);
        }
        else
        {
                _CritMoveItem(npc,armor,SLOT_INV);
        }

        npc.Wait(10000);
   }

   void TestVars(Critter@ npc)
   {
        GameVar@ var=GetGlobalVar(GVAR_game_state);
        if(@var==null)
        {
                npc.Say(SAY_NORM_ON_HEAD,"Not found");
                return;
        }

        int v=var.GetValue();

        npc.Say(SAY_NORM_ON_HEAD,"var="+v);

        var=Random(0,5);

        npc.Wait(5000);
   }

 */

void answer_Generic( Critter& player, uint answerI, string& answerS )
{
    player.Say( SAY_NETMSG, "Answer integer<" + answerI + ">, string<" + answerS + ">." );
}

void elevator( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_ELEVATOR, ELEVATOR_BOS_1234( p0 ), "answer_Generic" );
}

void dlgbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_DIALOGBOX, 5, "answer_Generic" );
    cr.Say( SAY_DIALOGBOX_TEXT, "Choose you button dude." );
    cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Button0" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Button1" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "Button2" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "Button3" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "Button4" );
}

void skillbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SKILLBOX, 0, "answer_Generic" );
}

void say( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SAY, p0, "answer_Generic" );
    cr.Say( SAY_SAY_TITLE, "Choose you..." );
    cr.Say( SAY_SAY_TEXT, "sometext" );
}

void timer( Critter& cr, int p0, int p1, int p2 )
{
    ProtoItem@ proto = GetProtoItem( PID_BOTTLE_CAPS );
    cr.ShowScreen( SCREEN_TIMER, proto.PicInv, "answer_Generic" );
}

void bag( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_BAG, 0, "answer_Generic" );
}

void inventory( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_INVENTORY, 0, "" );
}

void cha( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CHARACTER, 0, "" );
}

void fixboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
}

void pipboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_PIPBOY, 0, "" );
}

void minimap( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_MINIMAP, 0, "" );
}

void close( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CLOSE, 0, "" );
}









// ok, just predictable log message about null pointer exception
// string@ SomeFunc(string& str)

// results in ICE: Assertion failed: tempVariables.GetLength() == 0, file ..\..\source\as_compiler.cpp, line 611
// string SomeFunc(string& str)

// crash
/*string SomeFunc(string& str)
   {
        string@[]@ forms = split(str, " ");
           // uncomment to reproduce crash
        // SomeFunc1(forms);
        return null;
   }

   void SomeFunc1(string@[]@ arr)
   {
        Log("Ok");
   }*/




void DLog( string& str )
{
    Log( str );
}


#include "_macros.fos"
#include "entire.fos"

// ent number for i-th room
// global value, but we can change it to be different per-npc
#define ENT    # (i)        ( 50 + i )



class SomeClassA
{
    int A;

    ~SomeClassA()
    {
        Log( "destruct" );
    }
}

class SomeClassB
{
    SomeClassA@ nullptr;
    SomeClassB( SomeClassA@ aPtr )
    {
        this.nullptr.A = 100;       // Null pointer access, but after this class a is destroyed
    }
}

void test10( Critter& crit, int p0, int p1, int p2 )
{
    SomeClassA a;
    SomeClassB( a );
}
/*
   void test11(Critter& cr, int p0, int p1, int p2)
   {
        Critter@ npc=GetCritter(uint(p0)+5000000);
        if(not valid(npc)) return;

        npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN,"_Begin");
        npc.SetEvent(CRITTER_EVENT_PLANE_END,"_End");

        NpcPlane@ plane=CreatePlane();
        plane.Type=AI_PLANE_WALK;
        plane.Priority=0;
        plane.Walk_HexX=p1;
        plane.Walk_HexY=p2;
        plane.Walk_Run=false;
        plane.Walk_Cut=0;

        NpcPlane@ plane2=CreatePlane();
        @plane.Child=plane2;
        plane2.Type=AI_PLANE_WALK;
        plane2.Priority=0;
        plane2.Walk_HexX=p1+10;
        plane2.Walk_HexY=p2;
        plane2.Walk_Run=false;
        plane2.Walk_Cut=0;

        npc.AddPlane(plane);
   }*/

void _Begin( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "Begin, reason: " + reason + "." );
}

void _End( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "End, reason: " + reason + "." );
}

#include "npc_planes.fos"
void test12( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    AddWalkPlane( npc, 2, cr.HexX, cr.HexY, cr.Dir, false, 2 );
    AddMiscPlane( npc, 1, __FullSecond + 3 * 60, null );
}

void plane_Misc( Critter& npc )
{
    npc.Say( SAY_NORM, "Ho-ho-ho." );
}


void test13( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    Log( "begin" );
    if( map.Reload() )
        Log( "ok" );
}

void test14( Critter& cr, int p0, int p1, int p2 )
{
    Map@ location = cr.GetMap();
    Log( "begin loc" );
    if( location.Reload() )
        Log( "ok" );
}

void test15( Critter& cr, int p0, int p1, int p2 )
{
    cr.RunClientScript( "__Test", p0, p1, p2, null, null );
}

void test16( Critter& cr, int p0, int p1, int p2 )
{
    uint[] ui( 3 );
    ui[ 0 ] = p0;
    ui[ 1 ] = p1;
    ui[ 2 ] = p2;
    CreateTimeEvent( __FullSecond + 5 * 60, "e_Test", ui, true );
}

uint e_Test( uint[] @ values )
{
    Log( "Values (" + values.length() + "): " + values[ 0 ] + ", " + values[ 1 ] + ", " + values[ 2 ] + "." );
    return REAL_SECOND( 5 );
}

void test17( Critter& cr, int p0, int p1, int p2 )
{
    Log( "Show callback." );
}

void testGroup( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;
    Critter@ npc2 = GetCritter( uint( p1 ) + 5000000 );
    if( not valid( npc2 ) )
        return;

    Critter@[] group( 2 );
    @group[ 0 ] = npc;
    @group[ 1 ] = npc2;

    cr.TransitToGlobal( group );
}

void testLex( Critter& cr, int p0, int p1, int p2 )
{
    Item@[] items;
    cr.GetItems( -1, items );
    for( uint i = 0; i < items.length(); i++ )
        items[ i ].SetLexems( "$Number" + Random( 100, 200 ) );

    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    npc.SetLexems( "$name" + "Dude" );
    Log( "Done" );
}

void testFly( Critter& cr, int p0, int p1, int p2 )
{
    Log( "x " + cr.HexX + " y " + cr.HexY );
    cr.GetMap().RunFlyEffect( p0, null, null, cr.HexX, cr.HexY, p1, p2 );
}

void testDelItem( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cl = GetCritter( uint( p0 ) );
    if( not valid( cl ) )
        return;
    DeleteItem( cl.GetItem( 0, p1 ) );
}

void testSwap( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr1 = GetCritter( uint( p0 ) );
    Critter@ cr2 = GetCritter( uint( p1 ) );
    SwapCritters( cr1, cr2, true, true );
}


/*#pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
#pragma globalvar "bool aaaa = true"*/


void test_find( Critter& cr, int p0, int p1, int param2 )
{
    Map@ map = cr.GetMap();
    int  f = 0;
    switch( p0 )
    {
    case 0:
        f = FIND_LIFE;
        break;
    case 1:
        f = FIND_KO;
        break;
    case 2:
        f = FIND_DEAD;
        break;
    case 3:
        f = FIND_LIFE_AND_KO;
        break;
    case 4:
        f = FIND_LIFE_AND_DEAD;
        break;
    case 5:
        f = FIND_KO_AND_DEAD;
        break;
    case 6:
        f = FIND_ALL;
        break;
    }
    uint count = map.GetNpcCount( param2, f );
    for( uint i = 0; i < count; i++ )
    {
        Critter@ cow = map.GetNpc( param2, f, i );
        map.SetText( cow.HexX, cow.HexY, COLOR_RGB( 255, 0, 0 ), "" + count );
    }
    cr.Say( SAY_NORM_ON_HEAD, "" + f );
}


import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void AffectPoison( Critter& cr, int value ) from "poison";

void testPlague( Critter& cr, int isRad, int value, int p2 )
{
    if( isRad != 0 )
        AffectRadiation( cr, value );
    else
        AffectPoison( cr, value );
    cr.Say( SAY_NETMSG, "rad " + cr.Stat[ ST_RADIATION_LEVEL ] );
    cr.Say( SAY_NETMSG, "psn " + cr.Stat[ ST_POISONING_LEVEL ] );
}

void LocInfo( Critter& cr, int isRad, int value, int p2 )
{
    Location@ loc = cr.GetMap().GetLocation();
    cr.Say( SAY_NETMSG, "MapPid " + cr.GetMap().GetProtoId() );
    cr.Say( SAY_NETMSG, "LocPid " + loc.GetProtoId() );
    cr.Say( SAY_NETMSG, "Visible " + ( loc.Visible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckVisible " + ( loc.GeckVisible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "AutoGarbage " + ( loc.AutoGarbage ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckCount " + loc.GeckCount );
    cr.Say( SAY_NETMSG, "Radius " + loc.Radius );
}

void GetCrIds( Critter& cr, int onlyNpc, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] critters;
        for( uint i = 0, j = map.GetCritters( 0, FIND_ALL | ( onlyNpc == 1 ? FIND_ONLY_NPC : 0 ), critters ); i < j; i++ )
            cr.Say( SAY_NETMSG, critters[ i ].Name + " " + critters[ i ].Id );
    }
}

void CrAddItem( Critter& cr, int crId, int pid, int count )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.AddItem( pid, count );
}

void AddExp( Critter& cr, int crId, int val, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ ST_EXPERIENCE ] += val;
}

void SetStat( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ num ] = val;
}

void SetSkill( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.SkillBase[ num ] = val;
}

void SetPerk( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.PerkBase[ num ] = val;
}

/*
   import void ExplodeEx(Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId) from "explode";

   void Boom(Critter& cr, int damage, int damageRadius, int effRadius)
   {
        Map@ map=cr.GetMap();
        if(valid(map)) ExplodeEx(map,cr.HexX,cr.HexY,PID_EXPLODE_ROCKET,effRadius,damage,DAMAGE_EXPLODE,damageRadius,0);
   }
 */

void TestLoc( Critter& cr, int locPid, int count, int )
{
    for( int i = 0; i < count; i++ )
    {
        Location@ loc = GetLocation( CreateLocation( locPid, 100, 100, null ) );
        Map@      map = loc.GetMapByIndex( 0 );
        Critter@[] critters;
        uint      crCount = map.GetCritters( 0, FIND_ALL, critters );
        for( uint j = 0; j < crCount; j++ )
        {
            for( uint k = 0; k < crCount; k++ )
            {
                if( j != k )
                    AddAttackPlane( critters[ j ], 0, critters[ k ] );
            }
        }
    }
}

void TestWorld( Critter& cr, int, int, int )
{
    // 1000 locations and maps
    // 100000 items
    // 5000 npc
    for( uint i = 0; i < 1000; i++ )
        CreateLocation( 101, 100, 100, null );
    // 242000
    for( uint i = 0; i < 242000; i++ )
        GetLocalVar( 3040, i );
    for( uint i = 0; i < 87000; i++ )
        GetUnicumVar( 2020, i, i );


// npc 7300 +
// uvar 87000 +
// lvar 242000 +
// holo 110 -
// maps 708 +
// loc 524 +
// items 105000 +
// anyd 1800 -
}

void CrClearInv( Critter& cr, int crId, int, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        Item@[] items;
        toCr.GetItems( -1, items );
        for( uint i = 0, j = items.length(); i < j; i++ )
            DeleteItem( items[ i ] );
    }
}

void SetType( Critter& cr, int crId, int crType, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ChangeCrType( crType );
        toCr.StatBase[ ST_BASE_CRTYPE ] = crType;
    }
}

void ChangeLook( Critter& cr, int, int, int )
{}

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId ) from "explode";
void        Boom( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
            ExplodeEx( cr.GetMap(), critters[ i ].HexX, critters[ i ].HexY, PID_EXPLODE_ROCKET, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
}

void Patch0( Critter& cr, int, int, int )
{
    Log( "Begin patch..." );
    Critter@[] npcs;
    GetAllNpc( 0, npcs );
    for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
        Critter@ npc = npcs[ i ];
        Map@     map = npc.GetMap();
        if( valid( map ) )
        {
            uint16 locPid = map.GetLocation().GetProtoId();
            // if(LOCATION_IS_CITY(locPid)) npc.Refresh();
        }
    }

    Location@ locHell = GetLocationByPid( LOCATION_ReplicationHell, 0 );
    locHell.Reload();
    Log( "End patch." );
}

void RandomTypes( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            int type = Random( 20, 90 );
            critters[ i ].ChangeCrType( type );
            critters[ i ].StatBase[ ST_BASE_CRTYPE ] = type;
        }
    }
}

void AllToVaultBoys( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            critters[ i ].ChangeCrType( 249 );
            critters[ i ].StatBase[ ST_BASE_CRTYPE ] = 249;
        }
    }
}

void AllMapsEveryBoom( Critter& cr, int, int, int )
{
    Map@[] maps;
    ::GetAllMaps( 0, maps );
    for( uint i = 0, j = maps.length(); i < j; i++ )
    {
        Map@   map = maps[ i ];
        uint16 locPid = map.GetLocation().GetProtoId();
        if( LOCATION_IS_CITY( locPid ) )
            CreateTimeEvent( __FullSecond, "e_Boom", map.Id, false );
    }
}

void RandomEveryBoom( Critter& cr, int, int, int )
{
    CreateTimeEvent( __FullSecond, "e_Boom", cr.GetMap().Id, true );
}

uint e_Boom( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
    {
        for( int i = 0; i < 4; i++ )
            ExplodeEx( map, Random( 10, map.GetWidth() - 10 ), Random( 10, map.GetHeight() - 10 ), PID_EXPLODE_ROCKET, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
    return REAL_SECOND( Random( 1, 4 ) );
}

void AllToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void NpcToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void AllToDead( Critter& cr, int deadType, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToDead( deadType, null );
    }
}

void ShowIds( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "My id is " + critters[ i ].Id );
}

void SetDustyScript( Critter& cr, int dustyId, int, int )
{
    Critter@ dusty = GetCritter( dustyId );
    if( valid( dusty ) )
        dusty.SetScript( "ncr_dusty@_DustyInit" );
}

void TestIndex( Critter& cr, int i, int, int )
{
    cr.StatBase[ ST_STRENGTH ] = 20;
    const int ii = cr.Stat[ ST_STRENGTH ];
    Log( "Strenght " + cr.Stat[ ST_STRENGTH ] );
}

void Transit( Critter& cr, int hx, int hy, int )
{
    cr.TransitToHex( hx, hy, 6 );
}

void GlobalCar( Critter& iam, int crId, int, int )
{
    Critter@ cr = ::GetCritter( crId );
    if( valid( cr ) )
    {
        Item@[] items;
        cr.GetItemsByType( ITEM_TYPE_CAR, items );
        for( uint i = 0; i < items.length(); i++ )
        {
            Item@ car = items[ i ];
            car.Charge = car.Proto.Car_TankVolume;
            car.Deterioration = 0;
            car.Update();
            iam.Say( SAY_NETMSG, "Done." );
        }
    }
}

void NullPtr( Critter& iam, int crId, int, int )
{
    Critter@ cr = GetCritter( 666 );
    if( iam.SkillBase[ 555 ] == 11 )
        crId = 0;
}

void AddHellTurret( Critter& iam, int pid, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( pid != 0 ? pid : 480, hx, hy, iam.Dir, null, null, null );
    turret.SetScript( "replication_hell@_TurretInit" );
}

uint NpcCrazyId = 0;
void NpcCrazyEvent( Critter& cr, int off, int, int )
{
    if( off != 0 )
        EraseTimeEvent( NpcCrazyId );
    else
        NpcCrazyId = CreateTimeEvent( __FullSecond, "e_NpcCrazy", cr.GetMap().Id, false );
}

uint e_NpcCrazy( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@[] players;
        map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players );
        for( uint l = 0, m = players.length(); l < m; l++ )
            AddAttackPlane( critters[ i ], 0, players[ l ] );
    }
    return REAL_SECOND( Random( 10, 40 ) );
}

void AddMadRobot( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( 480, hx, hy, iam.Dir, null, null, null );
    turret.StatBase[ ST_TEAM_ID ] = 19;
    turret.SetScript( "replication_hell@_TurretInit" );
//	turret.SetStat(ST_REPLICATION_TIME,1);
//	turret.SetPerk(PE_TERMINATOR,1);
    turret.AddItem( 520, 2 );
}

void AllNpcSetParam( Critter& cr, int index, int value, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].ParamBase[ index ] = value;
}

void AddGuard( Critter& cr, int, int, int )
{
    int[] params = { ST_DIALOG_ID, 2200, ST_TEAM_ID, 5 };
    int[] items = { PID_END_BOSS_PLASMA_GUN, 3, SLOT_INV };
    Critter@ guard = cr.GetMap().AddNpc( 369, cr.HexX, cr.HexY - 1, 2, params, items, "map_barter_ground@_GuardInit" );
}

void NpcFullDead( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_REPLICATION_TIME ] = -1;
        critters[ i ].ToDead( 1, null );
    }
}

void NpcReturn( Critter& cr, int replTime, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_REPLICATION_TIME ] = replTime;
        critters[ i ].ToLife();
    }
}

#include "_npc_pids.fos"
const uint16[] pids = { 54, 54, 54, 54, NPC_PID_MaleOrphan, NPC_PID_FemaleOrphan, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_MaleOrphan, NPC_PID_FemaleOrphan, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_AverageMerchantMale, NPC_PID_WeakMeleeGuardMale, NPC_PID_RaiderMale, NPC_PID_RaiderFemale };

void AddHostile( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ hostile = map.AddNpc( pids[ Random( 0, pids.length() - 1 ) ], hx, hy, iam.Dir, null, null, null );
    hostile.StatBase[ ST_TEAM_ID ] = 19;
    // hostile.SetStat(ST_REPLICATION_TIME,Random(5,10));
    CreateTimeEvent( __FullSecond, "e_HostileMove", hostile.Id, true );
}

uint SufferingLastTime = 0;
uint e_HostileMove( uint[] @ values )
{
    Critter@ hostile = ::GetCritter( values[ 0 ] );
    if( not valid( hostile ) )
        return 0;

    if( hostile.IsLife() )
    {
        hostile.MoveRandom();

        if( __FullSecond > SufferingLastTime )
        {
            string say;
            switch( Random( 0, 50 ) )
            {
            case 0:
                say = "Малые страдания выводят нас из себя, великие же - возвращают нас самим себе.";
                break;
            case 1:
                say = "Минутное удовольствие часто бывает причиной долгих страданий. ";
                break;
            case 2:
                say = "Кто боится страдания, тот уже страдает от боязни.";
                break;
            case 3:
                say = "Язвы желудка возникают не от того, что вы едите, а от того, что съедает вас. ";
                break;
            case 4:
                say = "Бедное раздавленное насекомое страдает так же, как умирающий гигант. ";
                break;
            case 5:
                say = "Молчание - величайшее из человеческих страданий; святые никогда не молчали. ";
                break;
            case 6:
                say = "Раны, нанесенные собственной рукой, всегда заживают медленнее, чем те, которые нанес противник. ";
                break;
            case 7:
                say = "Не умеешь нести бремя невзгод - усугубляешь их тяжесть. ";
                break;
            case 8:
                say = "Есть два способа преодолевать трудности: либо вы изменяете сами трудности, чтобы было легче с ними справится, либо, справляясь с ними изменяетесь сами. ";
                break;
            case 9:
                say = "Если мы еще можем любить тех, кто заставил нас страдать, то любовь наша лишь становится сильнее.  ";
                break;
            case 10:
                say = "Мужественный человек обыкновенно страдает, не жалуясь, человек же слабый жалуется, не страдая.";
                break;
            case 11:
                say = "Величайшее зло - страдание.";
                break;
            case 12:
                say = "Всеми страданиями вокруг нас должны страдать и мы. У всех у нас не одно тело, но одно развитие, а это проводит нас через все боли в той или иной форме. Как дитя проходит в своем развитии через все стадии жизни вплоть до старости и до смерти (и каждая стадия, в сущности, от страха или от желания, кажется предыдущей недостижимою), точно так же и мы (связанные с человечеством не менее глубоко, чем с самими собой) проходим в своем развитии через все страдания этого мира. Справедливости при таком положении нет места, но нет места и страху перед страданием или возможности истолковать страдание как заслугу.";
                break;
            case 13:
                say = "Издевательство над чужими страданиями не должно быть прощаемо.";
                break;
            case 14:
                say = "К величию есть только один путь, и этот путь проходит через страдания.";
                break;
            case 15:
                say = "Когда мне не дают роли, чувствую себя пианисткой, которой отрубили руки.";
                break;
            case 16:
                say = "Мы стремимся в большей степени к тому, чтобы отвести от себя страдания, нежели к тому, чтобы получить удовольствие.";
                break;
            case 17:
                say = "Обусловленное существование есть страдание. У страдания есть причина. У страдания есть конец, и есть пути, ведущие к этому концу.";
                break;
            case 18:
                say = "Только здесь страдать – это страдать. Не в том смысле, что те, кто страдает здесь, где-то в другом месте из-за этого страдания будут возвышенны, а в том смысле, что то, что именуется в этом мире страданием, в другом мире не изменяется, а только освобождено от своей противоположности, блаженства.";
                break;
            case 19:
                say = "Ты можешь отстраняться от страданий мира, это тебе разрешается и соответствует твоей природе, но, быть может, как раз это отстранение и есть единственное страдание, которого ты мог бы избежать.";
                break;
            case 20:
                say = "Человеческий разум может излечить от иллюзий, но не от страданий.";
                break;
            case 21:
                say = "Чем больше любят, тем больше страдают. Вся возможная для каждой души боль пропорциональна степени ее совершенства.";
                break;
            case 22:
                say = "Мудрый не горюет о потерянном, об умершем и о прошлом. Тем он отличается от глупца.";
                break;
            case 23:
                say = "Размышляй об изгнании, пытках, войнах, болезнях, кораблекрушениях, чтобы не быть новичком ни при каких бедствиях.";
                break;
            case 24:
                say = "Подлинное душевное спокойствие достигается примирением с самым худшим.";
                break;
            case 25:
                say = "Кто страдает раньше, чем это необходимо, тот страдает больше необходимого.";
                break;
            case 26:
                say = "Кто боится страданий, тот уже страдает от боязни.";
                break;
            case 27:
                say = "Ничтожным не бывает то, что больно нам.";
                break;
            case 28:
                say = "Моря человеческих слез не были бы так огромны, если бы не были бы так мелки.";
                break;
            case 29:
                say = "Чувствительный человек – точно безоружный среди хорошо вооруженных.";
                break;
            case 30:
                say = "Люди не бывают очень несчастны, если им не в чем раскаиваться.";
                break;
            case 31:
                say = "Чужие бедствия могут быть поводом к безропотности, но не к утешению.";
                break;
            case 32:
                say = "Огорчение существует не само по себе, а в нашем представлении.";
                break;
            case 33:
                say = "Мы созданы для несчастий. Слезы для сердца, что вода для рыб.";
                break;
            case 34:
                say = "В этом мире самым надежным развлечением для нас являются тревоги и страдания.";
                break;
            case 35:
                say = "Наш мир есть ничто иное, как скопление громадных страданий.";
                break;
            case 36:
                say = "Горечь – единственное накопление человека в жизни.";
                break;
            case 37:
                say = "Единственный способ быть счастливым – это любить страдания.";
                break;
            case 38:
                say = "В жизни, как и в природе, бывает гораздо больше пасмурных дней, чем безоблачных.";
                break;
            case 39:
                say = "Не чувствовать страданий не свойственно человеку, а не уметь их переносить не подобает мужчине.";
                break;
            case 40:
                say = "Ни с кем не случается ничего такого, что он не в силах был бы вынести.";
                break;
            case 41:
                say = "Мужайтесь и храните себя для благоприятных времен.";
                break;
            case 42:
                say = "Переноси с достоинством то, что изменить не сможешь.";
                break;
            case 43:
                say = "Кто переносит нетерпеливо, тот страдает вдвойне.";
                break;
            case 44:
                say = "Слезы для женщины – облегчение, для мужчины – пытка.";
                break;
            case 45:
                say = "Хочешь быть счастливым – выучись сперва страдать.";
                break;
            default:
                break;
            }
            if( say != "" )
                hostile.Say( SAY_NORM, say );
            SufferingLastTime = __FullSecond + Random( 3, 6 ) * 60;
        }
        else if( Random( 0, 100 ) == 0 )
            ExplodeEx( hostile.GetMap(), hostile.HexX, hostile.HexY, PID_EXPLODE_ROCKET, 10, 666, DAMAGE_EXPLODE, 10, 0 );
    }

    return REAL_SECOND( Random( 10, 20 ) );
}

void AttackTurret( Critter& cr, int, int, int )
{
    Critter@ turret;
    Map@     map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() == 480 )
        {
            @turret = critters[ i ];
            break;
        }

    }

    critters.resize( 0 );
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() != 480 )
        {
            AddAttackPlane( critters[ i ], 100, turret );
        }
    }
}


void TurretFrags( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() == 480 )
        {
            CreateTimeEvent( __FullSecond, "e_HostileMove", critters[ i ].Id, true );
            break;
        }

    }
}

uint e_TurretFrags( uint[] @ values )
{
    Critter@ turret = ::GetCritter( values[ 0 ] );
    uint     frags = 0; // =turret.GetKill(BT_MEN)+turret.GetKill(BT_WOMEN)+turret.GetKill(BT_CHILDREN);
    turret.Say( SAY_NORM_ON_HEAD, "Frags " + frags );
    return REAL_SECOND( 3 );
}

void TurretParam( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_BONUS_LOOK ] = 1000;
    }
}

void CreateCar( Critter& cr, int pid, int ox, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX + ox, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;

    uint keyId = Random( 10000, 50000 );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;
    cr.AddItem( PID_BLUE_PASS_KEY, 1 ).LockerId = keyId;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." );
}

void CreateCarPersonal( Critter& cr, int pid, int crId, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;
    _CarSetNoLockpick( car );

    uint keyId = _CritEyesDoorId( crId );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." );
}

void AllTo3d( Critter& cr, int, int, int )
{
    Critter@[] critters;
    cr.GetMap().GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        int rnd = Random( 290, 316 );
        critters[ i ].ChangeCrType( rnd );
        critters[ i ].StatBase[ ST_BASE_CRTYPE ] = rnd;
    }
}

void TestLexem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.SetLexems( "test test test" );
        item.Update();
    }
}

class Prop
{
    void set_Test( uint value ) {}
    uint get_Test() const       { return 0; }
};
void TestProp( Critter& cr, int, int, int )
{
    Prop p;
    uint i = ( p.Test - 1 );
}

// #pragma bindfunc "uint TestFunc(int, int) -> fo_test.dll TestFunc"
/*#pragma bindfunc "uint TestFunc(int, int) -> fo_test.dll TestFunc"
   #pragma bindfunc "bool Critter::TestMethod(int, uint, bool) -> fo_test.dll Critter_TestMethod"

   void TestDll(Critter& cr, int, int, int)
   {
        int i = TestFunc(1, 2);
        Log("TestFunc = " + i);

        i = cr.TestMethod(1, 2, true) ? 1 : 0;
        Log("TestMethod " + i);

        cr.SetEvent(CRITTER_EVENT_TALK, " fo_test.dll @ EventTalk ");
        i = cr.EventTalk(cr, true,666) ? 1 : 0;
        Log("EventTalk " + i);
   }*/

void TestScriptTimeout( Critter& cr, int, int, int )
{
    Test2();
}
void Test2()
{
    Test3();
}
void Test3()
{
    int ggg = 1;
    do
    {
        ggg = Random( 1, 100 );
    }
    while( ggg != 0 );
}

void TestNullptr( Critter&, int, int, int )
{
    Critter@ cr;
    Log( "begin" );
    uint     id = cr.Id;
    Log( "end" );
}

// Synchronizer TestLocker;
void TestScriptConcurrent( Critter& cr, int test, int, int )
{
    // TestLocker.Lock();

    Synchronize();
    Map@ map = cr.GetMap();
    Resynchronize();

    if( test == 1 )
        Resynchronize();             // Invalid call
    else if( test == 2 )
        Synchronize();               // Call without Resynchronize

    if( test == 5 )
    {
        for( int i = 0; i < 1000; i++ )
            CreateTimeEvent( 0, "e_TestScriptConcurrent", false );
    }
}

int Data = 0;
uint e_TestScriptConcurrent( uint[] @ values )
{
    // TestLocker.Lock();

    if( Data == 0 )
        Data++;
    else if( Data == 1 )
        Data--;
    else
        Log( "Fail!" );
    return 1;
}

void TestLog( Critter& cr, int, int, int )
{
    for( uint i = 0; i < 10000; i++ )
        Log( "Test message " + i );
}

void TestMapLoop( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetEvent( MAP_EVENT_LOOP_3, "_MapLoopEvent" );
    map.SetLoopTime( 3, 1000 );
    Log( "ok" );
}

void _MapLoopEvent( Map& map )
{
    Log( "_MapLoopEvent " + map.Id );
}

void patchBunker( Critter& cr, int, int, int )
{
    Location @ loc = GetLocationByPid( 21, 0 );    // LOCATION_TechBunker(21)
    if( @loc != null )
    {
        uint locId = loc.Id;
        DeleteLocation( locId );
        cr.Say( 11, "Location deleted. Id" + locId );     // SAY_NETMSG (11)
    }

    uint id = CreateLocation( 21, 1000, 1397, null );
    if( id == 0 )
    {
        cr.Say( 11, "Create location error: " + GetLastError() );
        return;
    }
    @ loc = GetLocation( id );

    if( @loc == null )
    {
        cr.Say( 11, "Get location error: " + GetLastError() );
        return;
    }

    loc.Visible = false;
    loc.GeckVisible = false;
    loc.AutoGarbage = false;
    loc.Radius = 6;
}

import void ClearPermanentDeath() from "replication";
void        ClearPermanentDeath( Critter& cr, int, int, int )
{
    ClearPermanentDeath();
}

void TestBlockItem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_RADIO, 1 );
    item.SetEvent( ITEM_EVENT_SKILL, "_ChangeMode" );
    UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
}

bool _ChangeMode( Item& item, Critter& cr, int skill )
{
    if( FLAG( item.Flags, ITEM_NO_BLOCK ) )
    {
        UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    else
    {
        SETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    item.Update();
    return false;
}

void DeleteTimeEvent( Critter& cr, int id, int, int )
{
    ::EraseTimeEvent( uint( id ) );
}

void HandToGround( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
        ::MoveItem( item, 0, cr.GetMap(), cr.HexX, cr.HexY );
}

void PatchItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        bool  canPickUp = false;
        switch( item.GetType() )
        {
        case ITEM_TYPE_ARMOR:
        case ITEM_TYPE_DRUG:
        case ITEM_TYPE_WEAPON:
        case ITEM_TYPE_AMMO:
        case ITEM_TYPE_MISC:
        case ITEM_TYPE_KEY:
            canPickUp = true;
            break;
        // case ITEM_TYPE_MISC_EX:
        case ITEM_TYPE_CONTAINER:
            canPickUp = FLAG( item.Flags, ITEM_CAN_PICKUP );
            break;
        case ITEM_TYPE_DOOR:
            SETFLAG( item.Flags, ITEM_NO_HIGHLIGHT );
            break;
        default:
            break;
        }
        switch( item.GetProtoId() )
        {
        case 148:
        case 150:
        case 154:
        case 156:
        case 850:
        case 851:
        case 852:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
            canPickUp = false;
            break;
        default:
            break;
        }
        if( canPickUp )
            SETFLAG( item.Flags, ITEM_CAN_PICKUP );
        else
            UNSETFLAG( item.Flags, ITEM_CAN_PICKUP );
    }
}

void ColorizeHandItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightIntensity = Random( 30, 80 );
        item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        item.LightDistance = ( dist != 0 ? dist : Random( 5, 15 ) );
        item.LightFlags = 0;

        if( ( flags % 10 ) == 1 )
        {
            _LightSetIgnoreDir( item, 0 );
            _LightSetIgnoreDir( item, 2 );
            _LightSetIgnoreDir( item, 4 );
        }
        else if( ( flags % 10 ) == 2 )
        {
            _LightSetIgnoreDir( item, 1 );
            _LightSetIgnoreDir( item, 3 );
            _LightSetIgnoreDir( item, 5 );
        }
        if( ( flags / 10 ) == 1 )
            _LightSetInverse( item );

        SETFLAG( item.Flags, ITEM_LIGHT );
        item.Update();
    }
}

void ColorizeHandItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void ColorizeLegsItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        // SETFLAG(item.Flags,ITEM_COLORIZE);
        item.Update();
    }
}

void ColorizeLegsItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_COLORIZE ) )
            UNSETFLAG( item.Flags, ITEM_COLORIZE );
        else
            SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void PatchLight( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        if( item.LightIntensity != 0 || item.Proto.LightIntensity != 0 )
            SETFLAG( item.Flags, ITEM_LIGHT );
    }
}

void ItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = cr.GetMap().GetItems( cr.HexX, cr.HexY, items );
    for( uint i = 0; i < count; i++ )
        cr.Say( SAY_NETMSG, "item " + items[ i ].GetProtoId() + " flags " + items[ i ].Flags );
}

void CheckAccess( Critter& cr, int, int, int )
{
    Map@[] maps;
    uint mapsCount = ::GetAllMaps( 0, maps );
    for( uint i = 0; i < mapsCount; i++ )
    {
        Map@ map = maps[ i ];
        Critter@[] players;
        uint count = map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, players );
        for( uint j = 0; j < count; j++ )
        {
            Critter@ player = players[ j ];
            if( player.GetAccess() > 0 )
                cr.Say( SAY_NETMSG, "Player " + player.Name + " access " + player.GetAccess() + "." );
        }
    }
    cr.Say( SAY_NETMSG, "Search complete." );
}

void Effect( Critter& cr, int radius, int, int )
{
    cr.GetMap().RunEffect( PID_EXPLODE_EMP, cr.HexX, cr.HexY + 10, radius );
}

void AddLoc( Critter& cr, int pid, int x, int y )
{
    if( ::CreateLocation( pid, x, y, null ) != 0 )
        cr.Say( SAY_NETMSG, "Success." );
    else
        cr.Say( SAY_NETMSG, "Fail." );
}

void DeleteNpc( Critter& cr, int crId, int, int )
{
    DeleteNpc( GetCritter( crId ) );
}

void EndTB( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetTurnBasedAvailability( false );
    map.EndTurnBased();
}

void TestVar( Critter& cr, int i, int, int )
{
    /*GameVar@ var=GetLocalVar(LMVAR_test_local_map,cr.GetMapId());
       Log("var="+var.GetValue());

       if(i!=0) var=i;

       Log("var="+var.GetValue());

       Log("begin vars generating");
       for(int i=1;i<1000000;i++)
       {
            GameVar@ var=GetLocalVar(LIVAR_test_local_item,i);
            var=Random(0,10);
            var=7;
       }
       Log("end vars generating");
     */
//	GVAR_test_global
//	LVAR_test_local
//	UVAR_test_unicum
//	LLVAR_test_local_loc
//	LMVAR_test_local_map
//	LIVAR_test_local_item
}

void TestTE( Critter& cr, int set, int, int )
{
    uint num = CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_TestTE", -8, false );
    Log( "created " + num );

    uint duration = 0;
    uint[] values;
    if( GetTimeEvent( num, duration, values ) )
    {
        Log( "get ok+ duration " + duration );
        for( uint i = 0; i < values.length(); i++ )
            Log( i + ") " + values[ i ] );
        Log( "get ok-" );

        if( set != 0 )
        {
            values[ 0 ] = 123;
            uint value = 456;
            values.insertLast( value );
            if( SetTimeEvent( num, duration, values ) )
            {
                Log( "set ok+" );
                for( uint i = 0; i < values.length(); i++ )
                    Log( i + ") " + values[ i ] );
                Log( "set ok-" );
            }
        }
    }
}

uint e_TestTE( int[] @ values )
{
    Log( "e_TestTE+" );
    for( uint i = 0; i < values.length(); i++ )
        Log( i + ") " + values[ i ] );
    Log( "e_TestTE-" );
    return 0;
}

void DoorKey( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;
    map.MoveHexByDir( hx, hy, cr.Dir, 1 );
    Item@ door = map.GetDoor( hx, hy );
    if( not valid( door ) )
        return;
    Item@ key = cr.AddItem( PID_TEMPLE_KEY, 1 );
    if( not valid( key ) )
        return;
    key.LockerId = door.LockerId;
    key.Update();
}

void HandToInv( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        if( cr.MoveItem( item.Id, 0, SLOT_INV ) )
            Log( "ok" );
        else
            Log( "fail" );
    }
}

void KillSpawn( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;

    map.MoveHexByDir( hx, hy, cr.Dir, 1 );

    Critter@ oldNpc = map.GetCritter( hx, hy );
    if( not valid( oldNpc ) )
        return;

    DeleteNpc( oldNpc );

    uint[] values = { map.Id, hx, hy };
    CreateTimeEvent( __FullSecond + REAL_MS( 50 ), "e_KillSpawn", values, false );
}

uint e_KillSpawn( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
        map.AddNpc( 20 + Random( 0, 10 ), values[ 1 ], values[ 2 ], 2, null, null, null );
    return 0;
}

import void DropDrugEffects( Critter& cr ) from "drugs";
void        DropDrugs( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < 10; i++ )
    {
        map.MoveHexByDir( hx, hy, iam.Dir, 1 );
        Critter@ cr = map.GetCritter( hx, hy );
        if( valid( cr ) )
        {
            DropDrugEffects( cr );
            cr.Say( SAY_NORM, "Drugs dropped." );
            break;
        }
    }
}

void ClearExplode( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    map.GetItems( PID_ACTIVE_DYNAMITE, items );
    map.GetItems( PID_ACTIVE_PLASTIC_EXPLOSIVE, items );
    map.GetItems( PID_ACTIVE_MINE, items );

    DeleteItems( items );
}

void Sandbags( Critter& iam, int lineLen, int skipLen, int stackCount )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 pid = PID_SANDBAG_EMPTY;
    if( stackCount != 0 )
        pid = PID_SANDBAG_1 - 1 + stackCount;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.AddItem( hx, hy, pid, 1 );
        }
    }
}

void ClearItems( Critter& iam, int lineLen, int skipLen, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.GetItems( hx, hy, items );
        }
    }

    DeleteItems( items );
}

import void PlayMusic( Map& map, string& musicName, uint pos, uint repeat ) from "media";
void        BattleMusic( Critter& iam, int index, int, int )
{
    if( index == 1 )
        PlayMusic( iam.GetMap(), "02 - Into The Dust.ogg", 0, 0 );
    else if( index == 2 )
        PlayMusic( iam.GetMap(), "07 - Echelon.ogg", 0, 0 );
    else if( index == 3 )
        PlayMusic( iam.GetMap(), "11 - Face To Face.ogg", 0, 0 );
    else if( index == 4 )
        PlayMusic( iam.GetMap(), "16 - Stranglet.ogg", 0, 0 );
    else if( index == 5 )
        PlayMusic( iam.GetMap(), "17 - Trinity.ogg", 0, 0 );
    else
        PlayMusic( iam.GetMap(), "01 - No Fate No Fear.ogg", 0, 0 );
}

void FixPlayer( Critter& admin, int id, int, int )
{
    Critter@ cr = ::GetCritter( id );
    if( valid( cr ) )
    {
        if( cr.StatBase[ ST_BONUS_LOOK ] == 9999 )
        {
            cr.StatBase[ ST_BONUS_LOOK ] = 0;
            if( cr.Perk[ PE_SHARPSHOOTER ] != 0 )
                cr.StatBase[ ST_BONUS_LOOK ] = 6;
            admin.Say( SAY_NETMSG, "Fixed bonus look." );
        }

        if( cr.StatBase[ ST_REPLICATION_TIME ] == -1 )
        {
            cr.StatBase[ ST_REPLICATION_TIME ] = 0;
            cr.TimeoutBase[ TO_REPLICATION ] = 0;
            admin.Say( SAY_NETMSG, "Fixed replication." );
        }

        cr.SetEvent( CRITTER_EVENT_DEAD, null );
    }
    else
    {
        admin.Say( SAY_NETMSG, "Not found." );
    }
}

void SetAnim1( Critter& cr, int value, int, int )
{
    cr.SetAnims( 0, value, 0 );
}

void Pos( Critter& cr, int newPos, int, int )
{
    // 0 - stand, 1 - crouch, 2 - prone
    int curPos = ( ( cr.Anim1Life & ANIM1_CROUCH ) != 0 ? 1 : ( ( cr.Anim1Life & ANIM1_PRONE ) != 0 ? 2 : 0 ) );
    switch( curPos )
    {
    case 0:
        switch( newPos )
        {
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_PRONE, null, false, true );
            break;
        default:
            break;
        }
        break;
    case 1:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_STAND, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_PRONE, null, true, true );
            break;
        default:
            break;
        }
        break;
    case 2:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_STAND, null, false, true );
            break;
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }
    switch( newPos )
    {
    case 0:
        cr.SetAnims( 0, 0, 0 );
        break;
    case 1:
        cr.SetAnims( 0, ANIM1_CROUCH, 0 );
        break;
    case 2:
        cr.SetAnims( 0, ANIM1_PRONE, 0 );
        break;
    default:
        break;
    }
}

void ColorOffset( Critter& cr, int skin, int hair, int armor )
{
    cr.SetAnims( 0, ANIM1_COLOR_SKIN( skin ) | ANIM1_COLOR_HAIR( hair ) | ANIM1_COLOR_ARMOR( armor ), 0 );
}

void Shield( Critter& cr, int on, int, int )
{
    if( on != 0 )
        cr.SetAnims( 0, ANIM1_SHIELD, 0 );
    else
        cr.SetAnims( 0, 0, 0 );
}

void Palette( Critter& cr, int index, int, int )
{
    cr.SetAnims( 0, ANIM1_PALETTE( index ), 0 );
}

void SetWalk( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_WALK_TIME ] = time;
    cr.ModeBase[ MODE_NO_WALK ] = off;
}

void SetRun( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_RUN_TIME ] = time;
    cr.ModeBase[ MODE_NO_RUN ] = off;
}



void excep0( Critter& cr, int, int, int )
{
    Log( "excep0" );
    excep1( cr );
}
void excep1( Critter& cr )
{
    Log( "excep1" );
    int y = 100;
    excep2( 6 );
}
void excep2( int i )
{
    Log( "excep2" );
    for( int k = 0; k < 10; k++ )
        excep3();
}
void excep3()
{
    Log( "excep3" );
    int h = 0;
    int k = 10 / h;
}

void toDead( Critter& cr, int, int, int )
{
    cr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, null );
}
void toLife( Critter& cr, int, int, int )
{
    cr.ToLife();
}
void toKO( Critter& cr, int, int, int )
{
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, cr.HexX, cr.HexY );
}

#pragma bindfunc "bool TestScriptCallNative(string&, string&) -> fonline_test.dll TestScriptCallNative"
void testScriptCall( Critter&, int, int, int )
{
    if( TestScriptCallNative( "test", "double TestScriptCallAS(int v1, uint64 v2, float v3, string@ v4)" ) )
        Log( "testScriptCall success." );
    else
        Log( "testScriptCall fail." );
}
double TestScriptCallAS( int v1, uint64 v2, float v3, string@ v4 )
{
    Log( "TestScriptCall: " + v1 + ", " + v2 + ", " + v3 + ", " + v4 + "." );
    return 1.234567890;
}

#pragma bindfunc "void StringExample() -> fonline_test.dll StringExample"
void testStringExample( Critter&, int, int, int )
{
    StringExample();
}


void animate( Critter& cr, int anim1, int anim2, int )
{
    cr.Animate( anim1, anim2, null, true, true );
}
