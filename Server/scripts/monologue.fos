// Author rifleman17
// Монологи для НПЦ: несколько фраз. повторяемых через определенные промежутки времени.
// Указывается первая и последняя строка монолога, время, через которое повторится монолог и т.д.
// Строки должны быть записаны в FOTEXT.MSG
// Строки монолога должны нумероваться подряд.
// Если время следующего диалога равно нулю, все записи из AnyData будут удалены после первого использования

#include "_macros.fos"
#include "serializator.fos"

#define _AnyDataKey         # (crId)     ( "Monologue_" + crId )
#define CTE_RUN_MONOLOG     ( 60 )
#define CTE_NEXT_MESSAGE    ( 61 )

bool MonologueRunning( Critter& cr ) // Export
{
    return valid( GetMonologue( cr ) );
}

void SetMonologue( Critter@ cr, uint firstStr, uint lastStr, uint nextMsg, uint nextDialog, uint8 sayType ) // Export
{
    Monologue@ m = Monologue( firstStr, lastStr, nextMsg, nextDialog, sayType, cr.Id );
    if( valid( m ) )
    {
        m.ScheduleMonologue();
    }
}

Monologue@ GetMonologue( Critter@ cr )
{
    if( !valid( cr ) )
        return null;
    Monologue@ m = Monologue( cr.Id );
    if( !valid( m ) || !m.Exist() )
        return null;
    m.Load();
    return m;
}

class Monologue
{
    Monologue( uint critterId )
    {
        this.CritterId = critterId;
    }
    Monologue( uint firstStr, uint lastStr, uint nextMsg, uint nextDialog, uint8 sayType, uint critterId )
    {
        this.FirstString = firstStr;
        this.LastString = lastStr;
        this.CurrentString = 0;
        this.NextMessage = nextMsg;
        this.NextDialogue = nextDialog;
        this.SayType = sayType;
        this.CritterId = critterId;
        this.Save();
    }

    uint  FirstString;       // Номер первой строки в монологе
    uint  LastString;        // Номер последней строки
    uint  CurrentString;     // Текущая строка
    uint  NextMessage;       // Время следующей фразы в монологе в секундах
    uint  NextDialogue;      // Время следующего монолога
    uint8 SayType;           // Тип разговора (шепот, эмоции итд)
    uint  CritterId;         // Код криттера, читающего монолог

    bool Exist()
    {
        return IsAnyData( _AnyDataKey( this.CritterId ) );
    }

    // Сериализация в AnyData
    void Save()
    {
        Serializator save;
        save.Set( this.FirstString );
        save.Set( this.LastString );
        save.Set( this.CurrentString );
        save.Set( this.NextMessage );
        save.Set( this.NextDialogue );
        save.Set( this.SayType );
        save.Set( this.CritterId );
        save.Save( _AnyDataKey( this.CritterId ) );
    }

    void Load()
    {
        Serializator load;
        if( !load.Load( _AnyDataKey( this.CritterId ) ) )
            return;
        load.Get( this.FirstString );
        load.Get( this.LastString );
        load.Get( this.CurrentString );
        load.Get( this.NextMessage );
        load.Get( this.NextDialogue );
        load.Get( this.SayType );
        load.Get( this.CritterId );
    }

    void Erase()
    {
        if( this.Exist() )
        {
            EraseAnyData( _AnyDataKey( this.CritterId ) );
        }
    }

    void ScheduleMonologue()
    {
        Critter@ cr = GetCritter( this.CritterId );
        if( !valid( cr ) )
            return;
        if( cr.GetTimeEvents( CTE_RUN_MONOLOG, null, null, null ) == 0 )
        {
            cr.AddTimeEvent( "cte_RunMonologue", this.NextDialogue, CTE_RUN_MONOLOG );
        }
    }

    void ScheduleMessage()
    {
        Critter@ cr = GetCritter( this.CritterId );
        if( !valid( cr ) )
            return;
        if( cr.GetTimeEvents( CTE_NEXT_MESSAGE, null, null, null ) == 0 )
        {
            cr.AddTimeEvent( "cte_NextMessage", this.NextMessage, CTE_NEXT_MESSAGE );
        }
    }

}
// Начало диалога
uint cte_RunMonologue( Critter& cr, int identifier, uint& rate )
{
    Monologue@ m = GetMonologue( cr );
    if( valid( m ) )
    {
        m.CurrentString = m.FirstString;
        m.Save();
        m.ScheduleMessage();
        return m.NextDialogue;
    }
    return 0;
}

uint cte_NextMessage( Critter& cr, int identifier, uint& rate )
{
    Monologue@ m = GetMonologue( cr );
    if( valid( m ) )
    {
        if( m.CurrentString > m.LastString )
        {
            if( m.NextDialogue == 0 )           // Диалог одноразовый
                m.Erase();
            return 0;
        }
        cr.SayMsg( m.SayType, TEXTMSG_TEXT, m.CurrentString );
        m.CurrentString++;
        m.Save();
        return m.NextMessage;
    }
    return 0;
}

// Баллада паладина БС
bool d_MonologueRunning( Critter& player, Critter@ npc )
{
    return ( valid( npc ) && MonologueRunning( npc ) );
}

bool d_NotMonologueRunning( Critter& player, Critter@ npc )
{
    return !d_MonologueRunning( player, npc );
}

void r_RunMonologue( Critter& player, Critter@ npc, int firstStr, int lastStr, int nextMsg, int nextDialog, int sayType )
{
    SetMonologue( npc, firstStr, lastStr, nextMsg * __TimeMultiplier, nextDialog, sayType );
}
