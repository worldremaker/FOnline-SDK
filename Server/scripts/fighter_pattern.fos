// специализированный инструмент для настройки поведения нпц в команде на конкретной карте

#include "_macros.fos"
#include "_animation.fos"


#define _CanGenStim          StatBase[ ST_VAR4 ]                                            // признак: может создать стимпак
#define _AllyAssistRadius    StatBase[ ST_VAR5 ]                                            // радиус, на котором моб ищет напарников при попадании игрока в область видимости
#define _AssistAlliesNum     StatBase[ ST_VAR6 ]                                            // число напарников, которые будут вызваны на помощь
#define _MustHealLvl         StatBase[ ST_VAR7 ]                                            // когда использовать стимпаки
#define _LocalAlarmDeads     StatBase[ ST_VAR8 ]                                            // локальная тревога
#define _GlobalAlarmDeads    StatBase[ ST_VAR9 ]                                            // глобальная тревога
#define _EnemySpotted        GetData( 1 )                                                   // признак - уже кто-то заметил игрока

#define _DeadAllies          # (teamId)                                   GetData( teamId ) // число убитых напарников

#define TeamId               StatBase[ ST_TEAM_ID ]


#define MSG_KILLEM           ( 17 )                                         // код сообщения "убить гада"

import void UseDrugOn( Critter& cr, Critter& onCr, Item& drug ) from "drugs";

// счетчик убитых напарников (с тем же TeamID)
int DeadAllyCounter( Critter& cr )
{
    if( !valid( cr.GetMap() ) )
        return 0;

    if( cr.IsPlayer() )
        return 0;

    if( cr.TeamId == 0 )
        return 0;

    return cr.GetMap()._DeadAllies( cr.TeamId );

}

void AddDeadAlly( Critter& cr )
{
    if( !valid( cr.GetMap() ) )
        return;

    if( cr.IsPlayer() )
        return;

    if( cr.TeamId == 0 )
        return;

    cr.GetMap().SetData( cr.TeamId, DeadAllyCounter( cr ) + 1 );
}



// map карта с мобами
// teamId - номер команды моббов
// aDist - дистанция атаки видимого игрока
// alRadius - радиус реакции нпц на нападение моба из группы
// alNum - число мобов, которые подключаются к атаке
// hLvl - значение здоровья, при котором моб будет лечиться стимпаками
// locAlarm - число смертей мобов после которого остальные подходят к нападающему
// globAlarm - число смертей мобов, после которого все мобы на карте присоединяются к бою
// fArmLvl - коэффициент усиления брони и резистов моба
void SetMapMobsTemplate( Map& map, uint teamId, int aDist, int alRadius, int alNum, int hLvl, int locAlarm, int globAlarm, int fArmLvl )
{
    FighterPattern @ fp = FighterPattern();
    fp.AttackDist = aDist;
    fp.AllyAssistRadius = alRadius;
    fp.AssistAlliesNum = alNum;
    fp.MustHealLvl = hLvl;
    fp.LocalAlarmDeads = locAlarm;
    fp.GlobalAlarmDeads = globAlarm;
    fp.ForceArmourLvl = fArmLvl;

    Critter @[] critters;
    map.GetCritters( 0, FIND_LIFE | FIND_ONLY_NPC, critters );

    for( uint i = 0; i < critters.length(); i++ )
    {
        if( uint( critters[ i ].TeamId ) != teamId )
            continue;
        fp.InitPattern( critters[ i ] );
    }
    map.SetEvent( MAP_EVENT_CRITTER_DEAD, "e_OnMapCritterDead" );
}

class FighterPattern
{
    FighterPattern()
    {}


    int AttackDist;       // расстояние, на котором начинается атака
    int AllyAssistRadius; // радиус, в котором ищем членов группы
    int AssistAlliesNum;  // число членов группы, которым отправится призыв о помощи
    int MustHealLvl;      // уровень в процентах от макс хп, после которого нпц пытается полечиться
    int LocalAlarmDeads;  // число смертей, после которых на помощь приходят все криттеры видящие нпц
    int GlobalAlarmDeads; // число смертей, после которых призыв о помощи пойдет по всей карте
    int ForceArmourLvl;   // уровень усиления брони и резистов криттера 0 - базовый


    void InitPattern( Critter& cr )
    {
        cr.ShowCritterDist1 = this.AttackDist;
        // DL("cr,GlobAl" +cr._GlobalAlarmDeads);
        cr._AllyAssistRadius = this.AllyAssistRadius;
        cr._AssistAlliesNum = this.AssistAlliesNum;
        cr._MustHealLvl = this.MustHealLvl;
        cr._LocalAlarmDeads = this.LocalAlarmDeads;
        cr._GlobalAlarmDeads = this.GlobalAlarmDeads;
        // DL("this.GlobalAlarmDeads;" + this.GlobalAlarmDeads+"cr,GlobAl" +cr._GlobalAlarmDeads);


        _SetOnDeadEvents( cr );
        _SetOnAttackedEvents( cr );
        _SetSeeEnemyEvents( cr );
        _SetOnItemDroppedEvents( cr );
        _SetOnMessageEvents( cr );
        _SetOnIddleEvents( cr );

        ForceCritterArmour( cr );
    }

    void ForceCritterArmour( Critter& cr )
    {

        if( this.ForceArmourLvl > 3 && Random( 1, 3 ) == 1 )
        {
            cr.PerkBase[ PE_TERMINATOR ] = 1;
            cr.StatBase[ ST_STRENGTH ] = 10;
            cr.StatBase[ ST_ENDURANCE ] = Random( 9, 10 );
            DL( "Terminator" );
        }

        for( int i = ST_NORMAL_RESIST; i <= ST_EXPLODE_RESIST; i++ )
        {
            cr.StatBase[ i ] = Random( 1, this.ForceArmourLvl ) * 20;
            cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 30, 180 );
        }
        // DL("-ForceArmourLvl" +this.ForceArmourLvl+ "startHealth = "+cr.StatBase[ST_MAX_LIFE]+" hp "+cr.StatBase[ST_CURRENT_HP]);
        cr.StatBase[ ST_MAX_LIFE ] = CLAMP( cr.StatBase[ ST_MAX_LIFE ] + this.ForceArmourLvl * 30, 50, 250 );
        cr.StatBase[ ST_CURRENT_HP ] = CLAMP( cr.StatBase[ ST_CURRENT_HP ] + this.ForceArmourLvl * 30, 50, 250 );
        // DL("+ForceArmourLvl" +this.ForceArmourLvl+ "startHealth = "+cr.StatBase[ST_MAX_LIFE]+" hp "+cr.StatBase[ST_CURRENT_HP]);

        //
    }

    void _SetOnAttackedEvents( Critter& cr )
    {
        cr._CanGenStim = Random( 1, 5 );
        cr.SetEvent( CRITTER_EVENT_ATTACKED, "e_CritterAttacked" );
    }

    void _SetSeeEnemyEvents( Critter& cr )
    {
        cr.SetEvent( CRITTER_EVENT_SHOW_CRITTER_1, "e_ShowCritter1" );
    }

    void _SetOnItemDroppedEvents( Critter& cr )
    {}

    void _SetOnDeadEvents( Critter& cr )
    {
        // cr.SetEvent(CRITTER_EVENT_DEAD,"e_CritterDead");
        // cr.SetEvent(CRITTER_EVENT_SMTH_DEAD,"e_CritterSmthDead");
    }

    void _SetOnMessageEvents( Critter& cr )
    {
        cr.SetEvent( CRITTER_EVENT_MESSAGE, "e_CritterMessage" );
    }

    void _SetOnIddleEvents( Critter& cr )
    {}


}
/************************Обработка событий*************************/
void e_OnMapCritterDead( Map& map, Critter& cr, Critter@ killer )
{
    if( cr.IsPlayer() )
    {
        if( map.GetCritters( 0, FIND_LIFE | FIND_ONLY_PLAYERS, null ) == 0 )
        {
            map.SetData( 1, 0 );
            DL( "All players dead" );
        }
    }
    else
    {
        AddDeadAlly( cr );
        if( !valid( killer ) )
            return;
        if( !killer.IsPlayer() )
            return;
        if( DeadAllyCounter( cr ) >= cr._GlobalAlarmDeads )
        {
            cr.SendMessage( MSG_KILLEM, killer.Id, MESSAGE_TO_ALL_ON_MAP );
            DL( "Global alarm called" + DeadAllyCounter( cr ) + "cr deads = _GlobalAlarmDeads" + cr._GlobalAlarmDeads );
            return;
        }
        if( DeadAllyCounter( cr ) >= cr._LocalAlarmDeads )
        {
            cr.SendMessage( MSG_KILLEM, killer.Id, MESSAGE_TO_WHO_SEES_ME );
            DL( "Local alarm called" + DeadAllyCounter( cr ) );
            return;
        }
    }
}

void e_ShowCritter1( Critter& cr, Critter& showCrit )
{

    if( !showCrit.IsPlayer() )
        return;
    // DL("see player");
    // на появление игроков реагируют только первые заметивщие
    if( cr.GetMap()._EnemySpotted > 0 )
        return;
    cr.GetMap().SetData( 1, 1 );

    // DL("See Critter mydist"+cr.ShowCritterDist1 + " and dist "+ GetCrittersDistantion(cr, showCrit));
    if( !showCrit.IsLife() )
        return;
    if( cr.CheckEnemyInStack( showCrit.Id ) )
        return;
    // DL("will attack Critter");
    e_CritterMessage( cr, cr, MSG_KILLEM, showCrit.Id );
    uint dist = GetCrittersDistantion( cr, showCrit );
    if( cr.ShowCritterDist1  >= dist )
    {

        Map @ map = cr.GetMap();
        if( !valid( map ) )
            return;

        Critter @[] critters;

        if( map.GetCrittersHex( cr.HexX, cr.HexY, cr._AllyAssistRadius, FIND_LIFE | FIND_ONLY_NPC, critters ) == 0 )
            return;

        for( uint i = 0; i < critters.length(); i++ )
        {
            if( i >= uint( cr._AssistAlliesNum ) )
                break;
            e_CritterMessage( critters[ i ], cr, MSG_KILLEM, showCrit.Id );
        }
    }
}
bool e_CritterAttacked( Critter& cr, Critter& attacker )
{
    DL( "try heal" );
    if( cr.Stat[ ST_CURRENT_HP ] * 100 > cr._MustHealLvl * cr.Stat[ ST_MAX_LIFE ] )
    {
        DL( "Heal not needed" );
        return false;
    }
    _TryHeal( cr );
    return false;
}
void e_CritterMessage( Critter& cr, Critter& fromCr, int message, int value )
{
    switch( message )
    {
    case MSG_KILLEM:
        if( _IsAlly( cr, fromCr ) )
        {
            if( !cr.IsLife() )
                return;
            if( !valid( GetCritter( value ) ) )
                return;
            if( !cr.CheckEnemyInStack( value ) )
            {
                cr.AddEnemyInStack( value );
                DL( "Added enemy: " + value );
            }
            else
            {
                DL( "Enemy already in stack: " + value );
            }
        }
        break;
    default:
        break;
    }
}



/********************Вспомогательные функции***********************/
// попытка полечиться, если криттер жив и есть стимпаки
bool _TryHeal( Critter& cr )
{
    if( !cr.IsLife() )
        return false;
    if( cr.CountItem( PID_SUPER_STIMPAK ) == 0 && Random( 1, 6 ) == 1 && cr._CanGenStim > 1 )
    {
        cr.AddItem( PID_SUPER_STIMPAK, 1 );
        cr._CanGenStim--;
        cr._CanGenStim--;
    }
    if( cr.CountItem( PID_SUPER_STIMPAK ) > 0 )
    {
        Item @ item = cr.GetItem( PID_SUPER_STIMPAK, -1 );
        UseDrugOn( cr, cr, item );
        _CritAnimateUse( cr );
        DL( "SuperStim used" );
        return true;
    }
    if( cr.CountItem( PID_STIMPAK ) == 0 && Random( 1, 4 ) == 1 && cr._CanGenStim > 0 )
    {
        cr.AddItem( PID_STIMPAK, 1 );
        cr._CanGenStim--;
    }
    if( cr.CountItem( PID_STIMPAK ) > 0 )
    {
        Item @ item = cr.GetItem( PID_STIMPAK, -1 );
        UseDrugOn( cr, cr, item );
        _CritAnimateUse( cr );
        DL( "Stim used" );
        return true;
    }
    DL( "no Stim in bag" );

    return false;

}
// признак = это свой (та же группа)
bool _IsAlly( Critter& cr1, Critter& cr2 )
{
    return cr1.TeamId != 0 && cr1.TeamId == cr2.TeamId;
}
void DL( string msg )
{
    // Log(msg);
}
